import{subscribe as e,proxy as t}from"valtio/vanilla";import*as r from"yjs";import s from"fast-deep-equal";const n=e=>"object"==typeof e&&null!==e,o=e=>null===e||"string"==typeof e||"number"==typeof e||"boolean"==typeof e,i=e=>"string"==typeof e||"number"==typeof e||"boolean"==typeof e,a=(e,t,r)=>{e?e.transact(r,t.transactionOrigin):r()},l=(i,f,p={})=>{const y=new WeakMap,u=(e,t)=>{a(f.doc,p,()=>{if(!n(e)||!y.has(e)||y.get(e)!==f.get(t))if(Array.isArray(e)){const s=new r.Array;y.set(e,s),c(e,s,p),f.set(t,s)}else if(n(e)){const s=new r.Map;y.set(e,s),l(e,s,p),f.set(t,s)}else{if(!o(e))throw new Error("unsupported p type");f.set(t,e)}})},A=(e,s)=>{const a=i[s];if(!n(a)||y.get(a)!==e)if(e instanceof r.Array){const r=t([]);y.set(r,e),c(r,e,p),i[s]=r}else if(e instanceof r.Map){const r=t(e.toJSON());y.set(r,e),l(r,e,p),i[s]=r}else{if(!o(e))throw new Error("unsupported y type");i[s]=e}};Object.entries(i).forEach(([e,t])=>{const o=f.get(e);Array.isArray(t)&&o instanceof r.Array&&s(t,o.toJSON())?(y.set(t,o),c(t,o,p)):!Array.isArray(t)&&n(t)&&o instanceof r.Map&&s(t,o.toJSON())?(y.set(t,o),l(t,o,p)):u(t,e)}),f.forEach((e,t)=>{const o=i[t];Array.isArray(o)&&e instanceof r.Array&&s(o,e.toJSON())?(y.set(o,e),c(o,e,p)):!Array.isArray(o)&&n(o)&&e instanceof r.Map&&s(o,e.toJSON())?(y.set(o,e),l(o,e,p)):A(e,t)}),e(i,e=>{e.forEach(e=>{const t=e[1];if(1!==t.length)return;const n=t[0];if("delete"===e[0])f.delete(n);else if("set"===e[0]){const e=i[n],t=f.get(n);s(t instanceof r.AbstractType?t.toJSON():t,e)||u(e,n)}})}),f.observe(e=>{e.keysChanged.forEach(e=>{const t=f.get(e);void 0===t?delete i[e]:A(t,e)})})},c=(o,f,p={})=>{const y=new WeakMap,u=(e,t)=>{if(Array.isArray(e)){const s=new r.Array;y.set(e,s),c(e,s,p),f.insert(t,[s])}else if(n(e)){const s=new r.Map;y.set(e,s),l(e,s,p),f.insert(t,[s])}else{if(!i(e))throw new Error("unsupported p type");f.insert(t,[e])}},A=(e,s)=>{if(e instanceof r.Array){const r=t([]);y.set(r,e),c(r,e,p),o.splice(s,0,r)}else if(e instanceof r.Map){const r=t(e.toJSON());y.set(r,e),l(r,e),o.splice(s,0,r)}else{if(!i(e))throw new Error("unsupported y type");o.splice(s,0,e)}};o.forEach((e,t)=>{const o=f.get(t);Array.isArray(e)&&o instanceof r.Array&&s(e,o.toJSON())?y.get(e)!==o&&(y.set(e,o),c(e,o,p)):!Array.isArray(e)&&n(e)&&o instanceof r.Map&&s(e,o.toJSON())?y.get(e)!==o&&(y.set(e,o),l(e,o,p)):i(e)&&i(o)&&e===o||u(e,t)}),f.forEach((e,t)=>{const a=o[t];Array.isArray(a)&&e instanceof r.Array&&s(a,e.toJSON())?y.get(a)!==e&&(y.set(a,e),c(a,e,p)):!Array.isArray(a)&&n(a)&&e instanceof r.Map&&s(a,e.toJSON())?y.get(a)!==e&&(y.set(a,e),l(a,e,p)):i(a)&&i(e)&&a===e||A(e,t)}),o.splice(f.length),e(o,e=>{const t=(e=>{const t=e.flatMap(e=>{if("resolve"===e[0]||"reject"===e[0])return[];if(1!==e[1].length)return[];const t=Number(e[1][0]);return Number.isFinite(t)?[[e[0],t,e[2],e[3]]]:[]}),r=(e,r)=>{let s=0,n=null;for(;e+s+1<t.length;){if(("set"===t[e+s+1][0]||"insert"===t[e+s+1][0])&&t[e+s+1][1]<r&&t[e+s+1][3]===t[e][2])return s+1;if(null!==n||"set"!==t[e+s+1][0]&&"insert"!==t[e+s+1][0]||t[e+s+1][1]!==r-(s+1)||void 0!==t[e+s+1][3])if(null===n&&e+s+1<t.length&&"set"===t[e+s+1][0]&&void 0!==t[e+s+1][3])n=[e+s+1,t[e+s+1][1]],s+=1;else{if(null===n||"set"!==t[e+s+1][0]||t[e+s+1][1]!==n[1]+(s+1-n[0])||void 0===t[e+s+1][3])return null;s+=1}else s+=1}return null},s=(e,r)=>{let s=0;for(;e+s+1<t.length&&"delete"===t[e+s+1][0]&&t[e+s+1][1]===r-(s+1);)s+=1;return s};let n=0;for(;n<t.length;)if("set"!==t[n][0]&&"insert"!==t[n][0]||void 0!==t[n][3])if(n>0&&"delete"===t[n][0]){const e=t[n][1],r=s(n,e);if("set"===t[n-1][0]&&t[n-1][1]===e-(r+1)&&t[n-1][2]===t[n][2]){const s=["delete",e-(r+1),t[n-1][3],void 0];t.splice(n-1,2),t.splice(n-1+r,0,s),n-=1}else n+=1}else n+=1;else{const e=r(n,t[n][1]);null!==e?(t.splice(n+e,1,["insert",t[n+e][1],t[n+e][2],void 0]),t.splice(n,1)):n+=1}return t})(e);s(f.toJSON(),o)||a(f.doc,p,()=>{t.forEach(e=>{const t=e[1];if("delete"===e[0])return void(f.length>t&&f.delete(t,1));const r=o[t];void 0!==r&&("set"===e[0]?(f.length>t&&f.delete(t,1),u(r,t)):"insert"===e[0]&&u(r,t))})})}),f.observe(e=>{if(s(o,f.toJSON()))return;let t=0;e.changes.delta.forEach(e=>{e.retain&&(t+=e.retain),e.delete&&o.splice(t,e.delete),e.insert&&(Array.isArray(e.insert)?e.insert.forEach((e,r)=>{A(e,t+r)}):A(e.insert,t),t+=e.insert.length)})})};export{c as bindProxyAndYArray,l as bindProxyAndYMap};
//# sourceMappingURL=index.modern.mjs.map
